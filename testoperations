Sure! Below is the structured setup for using **module-wise Terraform configurations**, with separate `.tfvars` files for **provisioned** and **pay-per-request** billing modes.

---

### 1. **Project Structure**  

```
dynamodb-terraform/
â”‚-- modules/
â”‚   â””â”€â”€ dynamodb/
â”‚       â”œâ”€â”€ main.tf
â”‚       â”œâ”€â”€ variables.tf
â”‚       â”œâ”€â”€ outputs.tf
â”‚       â”œâ”€â”€ locals.tf
â”‚-- envs/
â”‚   â”œâ”€â”€ provisioned.tfvars
â”‚   â”œâ”€â”€ pay_per_request.tfvars
â”‚-- provider.tf
â”‚-- terraform.tfvars  (if required for common vars)
â”‚-- versions.tf
â”‚-- README.md
```

---

### 2. **`modules/dynamodb/main.tf`**  
```hcl
resource "aws_dynamodb_table" "this" {
  name         = var.table_name
  billing_mode = var.billing_mode

  hash_key  = var.hash_key
  range_key = var.range_key

  dynamic "attribute" {
    for_each = var.attributes
    content {
      name = attribute.value["name"]
      type = attribute.value["type"]
    }
  }

  dynamic "global_secondary_index" {
    for_each = var.billing_mode == "PROVISIONED" ? var.global_secondary_indexes : []
    content {
      name               = global_secondary_index.value["name"]
      hash_key           = global_secondary_index.value["hash_key"]
      range_key          = global_secondary_index.value["range_key"]
      projection_type    = global_secondary_index.value["projection_type"]
      read_capacity      = local.read_capacity_ddb
      write_capacity     = local.write_capacity_ddb
    }
  }

  server_side_encryption {
    enabled     = var.encryption_enabled
    kms_key_arn = data.aws_kms_key.kms_key.arn
  }

  ttl {
    enabled        = var.ttl_enabled
    attribute_name = var.ttl_attribute_name
  }

  point_in_time_recovery {
    enabled = var.point_in_time_recovery_enabled
  }

  dynamic "replica" {
    for_each = toset(var.replica_region)
    content {
      region_name             = replica.value
      kms_key_arn             = data.aws_kms_key.region2KMS[0].arn
      propagate_tags          = true
      point_in_time_recovery  = var.point_in_time_recovery_enabled
    }
  }

  tags = var.tags
}

data "aws_kms_key" "kms_key" {
  key_id = var.kms_key_alias
}

data "aws_kms_key" "region2KMS" {
  count    = length(var.replica_region)
  provider = aws.region2
  key_id   = var.kms_key_alias
}
```

---

### 3. **`modules/dynamodb/variables.tf`**  
```hcl
variable "table_name" {}
variable "billing_mode" {}
variable "hash_key" {}
variable "range_key" {}
variable "attributes" {
  type = list(object({
    name = string
    type = string
  }))
}
variable "global_secondary_indexes" {
  type = list(object({
    name            = string
    hash_key        = string
    range_key       = string
    projection_type = string
  }))
}
variable "encryption_enabled" {}
variable "kms_key_alias" {}
variable "ttl_enabled" {}
variable "ttl_attribute_name" {}
variable "point_in_time_recovery_enabled" {}
variable "replica_region" {
  type = list(string)
}
variable "tags" {
  type = map(string)
}
variable "read_capacity" {}
variable "write_capacity" {}
```

---

### 4. **`modules/dynamodb/outputs.tf`**  
```hcl
output "dynamo_table_id" {
  value = aws_dynamodb_table.this.id
}

output "dynamo_table_arn" {
  value = aws_dynamodb_table.this.arn
}

output "dynamo_table_stream_arn" {
  value = aws_dynamodb_table.this.stream_arn
}
```

---

### 5. **`modules/dynamodb/locals.tf`**  
```hcl
locals {
  read_capacity_temp  = coalesce(var.read_capacity, 0)
  write_capacity_temp = coalesce(var.write_capacity, 0)
  read_capacity_ddb   = (lower(var.billing_mode) != "PROVISIONED") ? null : local.read_capacity_temp <= 0 ? 1 : local.read_capacity_temp
  write_capacity_ddb  = (lower(var.billing_mode) != "PROVISIONED") ? null : local.write_capacity_temp <= 0 ? 1 : local.write_capacity_temp
}
```

---

### 6. **`provider.tf`**  
```hcl
terraform {
  required_version = ">= 0.13.0"

  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = ">= 2.0"
    }
  }
}

provider "aws" {
  region = var.region
}

provider "aws" {
  alias  = "region2"
  region = length(var.replica_region) == 0 ? var.region : var.replica_region[0]
}
```

---

### 7. **Environment-specific variable files**  

#### **`envs/provisioned.tfvars`**  
```hcl
billing_mode = "PROVISIONED"

read_capacity  = 10
write_capacity = 10

table_name = "provisioned-dynamodb-table"

attributes = [
  {
    name = "id"
    type = "S"
  },
  {
    name = "timestamp"
    type = "N"
  }
]

global_secondary_indexes = [
  {
    name            = "GSI1"
    hash_key        = "id"
    range_key       = "timestamp"
    projection_type = "ALL"
  }
]

encryption_enabled = true
kms_key_alias      = "alias/aws/dynamodb"

ttl_enabled        = true
ttl_attribute_name = "ttl"

point_in_time_recovery_enabled = true

replica_region = ["us-west-1", "us-east-1"]

tags = {
  Environment = "production"
  Project     = "provisioned-project"
}
```

---

#### **`envs/pay_per_request.tfvars`**  
```hcl
billing_mode = "PAY_PER_REQUEST"

table_name = "pay-per-request-table"

attributes = [
  {
    name = "id"
    type = "S"
  },
  {
    name = "timestamp"
    type = "N"
  }
]

encryption_enabled = true
kms_key_alias      = "alias/aws/dynamodb"

ttl_enabled        = false
ttl_attribute_name = ""

point_in_time_recovery_enabled = false

replica_region = ["us-east-1"]

tags = {
  Environment = "development"
  Project     = "payperrequest-project"
}
```

---

### 8. **Deployment Commands**  

To deploy for **provisioned mode**, run:

```bash
terraform init
terraform apply -var-file="envs/provisioned.tfvars"
```

To deploy for **pay-per-request mode**, run:

```bash
terraform init
terraform apply -var-file="envs/pay_per_request.tfvars"
```

---

This structure allows you to manage DynamoDB configurations efficiently using **modules and environment-specific tfvars files**. Let me know if you need any changes! ðŸ˜Š
